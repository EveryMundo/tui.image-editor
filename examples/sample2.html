<!DOCTYPE html>
<html>
    <head>
    <title>listing directory /</title>
    </head>
    <body>
<canvas id="canvas" width=300 height=400></canvas>
<br>Original aspect:<br>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/3.6.0/fabric.js"></script>
        <script>
const canvas = new fabric.Canvas('canvas', {
  backgroundColor: 'lightgrey',
  width: 500,
  height: 500
});
const alignCenter = true;

var slot1 = new fabric.Rect({
  originX: 'left', 
  originY: 'top',
  left: 10, 
  top: 10,
  width: 200, 
  height: 400,
  fill: 'transparent',
  stroke: 'white',
  strokeWidth: 0,
  selectable: false
});
canvas.renderAll();

fabric.Image.fromURL('http://localhost:8080/examples/img/bg.jpg', (image) => {
  image.scale(0.5);
  image.set({
    left: 0,
    top: 0,
    hoverCursor: 'default',
    clipTo: function(ctx) {
			return clipBySlot(ctx, image, slot1);	 
    }
  })
  
  scaleImageToSlot(image, slot1);
  
  canvas.add(image);
  //canvas.add(slot1);
  canvas.renderAll();
});

function scaleImageToSlot(image, slot) {
  
  // Find smallest ratio of slot:width / image:width and slot:height / image: height
  let ratio = Math.min(slot.width / image.width, slot.height / image.height);
  console.log(`ratio width ${slot.width/image.width}, height ${slot.height/image.height}`);
  console.log('=> ratio', ratio);
  
  if(ratio <= 1) {
    image.scaleToWidth(slot.width);
    // console.log(image);
    let newHeight = image.height * image.scaleY;
    
    // console.log(`${newHeight} < ${slotHeight}?`)
    
    if(newHeight < slot.height) {
      image.scaleToHeight(slot.height);
    }
  }
  else {
    image.scaleToHeight(slot.height);
    let newWidth = image.width * image.scaleX;
    
    if(newWidth < slot.width) {
      image.scaleToWidth(slot.width);
    }
  }
  
  var shiftLeft = (slot.width - (image.width*image.scaleX)) / 2;
  var shiftTop = (slot.height - (image.height*image.scaleY)) / 2;
  console.log(`shift ${shiftLeft}x${shiftTop}`)
  
  if(alignCenter) {
      image.set({
          left: slot.left + shiftLeft,
          top: slot.top + shiftTop,
      });
  }
  else {
    if(image.left < slot.left) {
      // align image to center.
      image.setLeft(slot.left);
    }
    if(image.top < slot.top) {
      image.setTop(slot.top);
    }    
  }
  
}

function clipBySlot(ctx, image, slot) {
  var scaleXTo1 = (1 / image.scaleX);
  var scaleYTo1 = (1 / image.scaleY);
  
  // Save context of the canvas so it can be restored after the clipping
  ctx.save();
  
  ctx.translate(0, 0);
  ctx.rotate(degToRad(image.angle * -1));
  ctx.scale(scaleXTo1, scaleYTo1);
  
  ctx.beginPath();
  
  const boundingRect = image.getBoundingRect();
  // console.log(`[left] ${image.left} - (${boundingRect.width} / 2)`);
  
  ctx.rect(
    slot.left - image.left - Math.floor(boundingRect.width / 2),
    slot.top - image.top - Math.floor(boundingRect.height / 2),
    slot.width,
    slot.height
  );
  ctx.stroke()
  ctx.closePath();
  
  // Restore the original context.
  ctx.restore();
}

// Since the `angle` property of the Image object is stored 
// in degrees, we'll use this to convert it to radians.
function degToRad(degrees) {
  return degrees * (Math.PI / 180);
}

        </script>
    </body>
</html>

