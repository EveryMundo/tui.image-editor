<canvas id="a" width="300" height="300"></canvas>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/3.6.0/fabric.js"></script>
<script>
var bg = window._canvas = new fabric.Canvas('a');
var clipPath = new fabric.Circle({
  radius: 40,
  top: -40,
  left: -40,
  stroke: '#000000',
  strokeWidth: 1,
});

function job(instance, blurredImage) {
  instance.width *= instance.scaleX;
  instance.height *= instance.scaleY;

  instance.scaleX = 1;
  instance.scaleY = 1;

  const as = getRotatedLeft(instance);
  const diffLeft = (as.width - instance.width) / 2;
  const diffTop = (as.height - instance.height) / 2;
  let cropX = instance.left - (instance.width / 2);
  let cropY = instance.top - (instance.height / 2);

  adjustOriginPosition(blurredImage, 'end'); //center, center
  blurredImage.set('angle', instance.angle * -1);
  blurredImage.set({
    left: diffLeft * -1 + (as.width / 2),
    top: diffTop * -1 + (as.height / 2),
    width: as.width,
    height: as.height,
    cropX: cropX - diffLeft,
    cropY: cropY - diffTop
  });
  adjustOriginPosition(blurredImage, 'start'); //left, top

  bg.renderAll();
}

function getRotatedLeft(instance) {
    let {x: ax, y: ay} = instance.getPointByOrigin('left', 'top');
    let {x: bx, y: by} = instance.getPointByOrigin('right', 'top');
    let {x: cx, y: cy} = instance.getPointByOrigin('left', 'bottom');
    let {x: dx, y: dy} = instance.getPointByOrigin('right', 'bottom');

    const left = Math.min(ax, bx, cx, dx);
    const top = Math.min(ay, by, cy, dy);
    const right = Math.max(ax, bx, cx, dx);
    const bottom = Math.max(ay, by, cy, dy);

    const width = right - left;
    const height = bottom - top;

    return {
        left, top, width, height
    }
}

function makeInstance(copiedCanvas, left, top) {
    let blurredImage = new fabric.Image(copiedCanvas);

    let patternSourceCanvas = new fabric.StaticCanvas();
    const filter = new fabric.Image.filters.Pixelate({
        blocksize: 10
    });
    blurredImage.filters.push(filter);
    blurredImage.applyFilters();

    patternSourceCanvas.add(blurredImage);
    patternSourceCanvas.renderAll();

    const instance = new fabric.Rect({
        type: 'rect',
        left,
        top,
        stroke: '#000000',
        strokeWidth: 1,
        originX: 'center',
        originY: 'center',
        fill: new fabric.Pattern({
            source: function() {
              patternSourceCanvas.setDimensions({
                width: copiedCanvas.width,
                height: copiedCanvas.height
              });
              patternSourceCanvas.renderAll();

              return patternSourceCanvas.getElement();
            },
            repeat: 'no-repeat'
        }),
        objectCaching: false,
        width: 100,
        height: 100 
    });

    blurredImage.set({
      originX: 'left',
      originY: 'top',
      left: 0,
      top: 0,
      width: instance.width,
      height: instance.height,
      cropX: instance.left - (instance.width / 2),
      cropY: instance.top - (instance.height / 2),
    });
    instance.set({
        blurredImage
    })

    instance.on('rotating', (aa) => {
        job(instance, blurredImage);
    });

    instance.on('scaling', (aa) => {
        /*
      instance.width *= instance.scaleX;
      instance.height *= instance.scaleY;
      instance.scaleX = 1;
      instance.scaleY = 1;
      */
        console.log('scaling', instance);

      job(instance, blurredImage);
    });

    instance.on('moving', (aa) => {
      console.log('moving');
      job(instance, blurredImage);
    });

    return instance;
}


function adjustOriginPosition(text, editStatus) {
    let [originX, originY] = ['center', 'center'];
    if (editStatus === 'start') {
        [originX, originY] = ['left', 'top'];
    }

    const {x: left, y: top} = text.getPointByOrigin(originX, originY);
    text.set({
        left,
        top,
        originX,
        originY
    });
    text.setCoords();
}


fabric.Image.fromURL("http://localhost:8080/examples/img/bg.jpg", function (img) {
    bg.setBackgroundImage(img);
    bg.renderAll();

    const copiedCanvas = bg.toCanvasElement();

    const instance = makeInstance(copiedCanvas, 100, 100);
    const instance2 = makeInstance(copiedCanvas, 200, 200);

    bg.add(instance);
    bg.add(instance2);


});
bg.on('selection:updated', function (ss) {
    console.log('UPDATED - ', ss);
});

/*
bg.on('selection:cleared', function (ss) {
    console.log('selection:cleared', ss.deselected);
    if (ss.deselected.length > 0) {
        ss.deselected.forEach((item => {
            job(item, item.blurredImage);
        }));
    }
});
*/

bg.on('object:modified', function (ss) {
    if (ss.target.type === 'activeSelection') {
        const aa = bg.getObjects();
        const angle = ss.target.angle;
        const left = ss.target.left;
        const top = ss.target.top;
        
        aa.forEach((item => {
            ss.target.removeWithUpdate(item);
            job(item, item.blurredImage);
            ss.target.addWithUpdate(item);
        }));
        // bg.renderAll(); 
    }
});

</script>
